#!/usr/bin/env node
/**
 * CodeMate Pro - Component Generator CLI
 * Generate components for React, Angular, Python, Node.js, and Java
 * 
 * Copyright (c) 2025 - MIT License
 */

const fs = require('fs');
const path = require('path');
const readline = require('readline');

const SUPPORTED_FRAMEWORKS = ['react', 'angular', 'python', 'node', 'java'];
const COMPONENTS_DIR = path.join(__dirname, '..', 'components');
const TEMPLATES_DIR = path.join(__dirname, '..', 'templates');

// ANSI color codes
const colors = {
  reset: '\x1b[0m',
  green: '\x1b[32m',
  blue: '\x1b[34m',
  yellow: '\x1b[33m',
  red: '\x1b[31m',
  cyan: '\x1b[36m'
};

function log(message, color = 'reset') {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

function banner() {
  log(`
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë        CodeMate Pro - Component Generator      ‚ïë
‚ïë   Generate components for any framework        ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
`, 'cyan');
}

// Test file generators for each framework
const testGenerators = {
  react: (name, options = {}) => {
    const componentName = toPascalCase(name);
    return `import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import '@testing-library/jest-dom';
import { ${componentName} } from './${componentName}';

/**
 * ${componentName} Component Tests
 * Generated by CodeMate Pro
 */
describe('${componentName}', () => {
  // Setup and teardown
  beforeEach(() => {
    // Setup before each test
  });

  afterEach(() => {
    // Cleanup after each test
  });

  describe('Rendering', () => {
    it('should render without crashing', () => {
      render(<${componentName} />);
      expect(screen.getByTestId('${componentName.toLowerCase()}-container')).toBeInTheDocument();
    });

    it('should render children correctly', () => {
      render(<${componentName}>Test Content</${componentName}>);
      expect(screen.getByText('Test Content')).toBeInTheDocument();
    });

    it('should apply custom className', () => {
      render(<${componentName} className="custom-class" />);
      expect(screen.getByTestId('${componentName.toLowerCase()}-container')).toHaveClass('custom-class');
    });
  });

  describe('Loading State', () => {
    it('should show loading indicator when loading', () => {
      render(<${componentName} isLoading={true} />);
      expect(screen.getByText('Loading...')).toBeInTheDocument();
    });

    it('should hide loading indicator when not loading', () => {
      render(<${componentName} isLoading={false} />);
      expect(screen.queryByText('Loading...')).not.toBeInTheDocument();
    });
  });

  describe('User Interactions', () => {
    it('should handle click events', async () => {
      const handleClick = jest.fn();
      render(<${componentName} onClick={handleClick} />);
      
      fireEvent.click(screen.getByTestId('${componentName.toLowerCase()}-container'));
      
      await waitFor(() => {
        expect(handleClick).toHaveBeenCalledTimes(1);
      });
    });
  });

  describe('Props', () => {
    it('should accept and use custom props', () => {
      const testProps = {
        title: 'Test Title',
        description: 'Test Description'
      };
      
      render(<${componentName} {...testProps} />);
      // Add assertions based on your component's props
    });
  });

  describe('Accessibility', () => {
    it('should have proper ARIA attributes', () => {
      render(<${componentName} />);
      // Add accessibility assertions
    });
  });

  describe('Edge Cases', () => {
    it('should handle empty props gracefully', () => {
      render(<${componentName} />);
      expect(screen.getByTestId('${componentName.toLowerCase()}-container')).toBeInTheDocument();
    });

    it('should handle null children', () => {
      render(<${componentName}>{null}</${componentName}>);
      expect(screen.getByTestId('${componentName.toLowerCase()}-container')).toBeInTheDocument();
    });
  });
});
`;
  },

  angular: (name, options = {}) => {
    const componentName = toPascalCase(name);
    const selector = toKebabCase(name);
    return `import { ComponentFixture, TestBed, fakeAsync, tick } from '@angular/core/testing';
import { By } from '@angular/platform-browser';
import { ${componentName}Component } from './${selector}.component';

/**
 * ${componentName} Component Tests
 * Generated by CodeMate Pro
 */
describe('${componentName}Component', () => {
  let component: ${componentName}Component;
  let fixture: ComponentFixture<${componentName}Component>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      declarations: [${componentName}Component]
    }).compileComponents();

    fixture = TestBed.createComponent(${componentName}Component);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  afterEach(() => {
    fixture.destroy();
  });

  describe('Component Creation', () => {
    it('should create the component', () => {
      expect(component).toBeTruthy();
    });

    it('should have default values', () => {
      expect(component.customClass).toBe('');
      expect(component.isLoading).toBe(false);
    });
  });

  describe('Template Rendering', () => {
    it('should render the container element', () => {
      const container = fixture.debugElement.query(By.css('.${selector}-container'));
      expect(container).toBeTruthy();
    });

    it('should apply custom class when provided', () => {
      component.customClass = 'my-custom-class';
      fixture.detectChanges();
      
      const container = fixture.debugElement.query(By.css('.${selector}-container'));
      expect(container.nativeElement.classList).toContain('my-custom-class');
    });

    it('should show loading template when isLoading is true', () => {
      component.isLoading = true;
      fixture.detectChanges();
      
      expect(fixture.nativeElement.textContent).toContain('Loading...');
    });

    it('should show content when isLoading is false', () => {
      component.isLoading = false;
      fixture.detectChanges();
      
      expect(fixture.nativeElement.textContent).not.toContain('Loading...');
    });
  });

  describe('Input Properties', () => {
    it('should accept customClass input', () => {
      component.customClass = 'test-class';
      expect(component.customClass).toBe('test-class');
    });

    it('should accept isLoading input', () => {
      component.isLoading = true;
      expect(component.isLoading).toBe(true);
    });
  });

  describe('Output Events', () => {
    it('should emit actionTriggered event', () => {
      spyOn(component.actionTriggered, 'emit');
      
      component.onAction();
      
      expect(component.actionTriggered.emit).toHaveBeenCalled();
    });
  });

  describe('Lifecycle Hooks', () => {
    it('should call ngOnInit', () => {
      spyOn(component, 'ngOnInit');
      component.ngOnInit();
      expect(component.ngOnInit).toHaveBeenCalled();
    });

    it('should call ngOnDestroy', () => {
      spyOn(component, 'ngOnDestroy');
      component.ngOnDestroy();
      expect(component.ngOnDestroy).toHaveBeenCalled();
    });
  });

  describe('Async Operations', () => {
    it('should handle async operations', fakeAsync(() => {
      // Add async test logic here
      tick(1000);
      fixture.detectChanges();
      // Add assertions
    }));
  });
});
`;
  },

  python: (name, options = {}) => {
    const className = toPascalCase(name);
    const moduleName = toSnakeCase(name);
    return `"""
${className} Module Tests
Generated by CodeMate Pro

Unit tests for the ${className} component.
"""

import pytest
from unittest.mock import Mock, patch, MagicMock
from datetime import datetime
from ${moduleName} import ${className}, ${className}Config


class Test${className}Config:
    """Tests for ${className}Config dataclass."""

    def test_default_values(self):
        """Test default configuration values."""
        config = ${className}Config()
        
        assert config.enabled is True
        assert config.timeout == 30
        assert config.max_retries == 3
        assert config.options == {}

    def test_custom_values(self):
        """Test custom configuration values."""
        config = ${className}Config(
            enabled=False,
            timeout=60,
            max_retries=5,
            options={'key': 'value'}
        )
        
        assert config.enabled is False
        assert config.timeout == 60
        assert config.max_retries == 5
        assert config.options == {'key': 'value'}


class Test${className}:
    """Tests for ${className} class."""

    @pytest.fixture
    def component(self):
        """Create a ${className} instance for testing."""
        return ${className}()

    @pytest.fixture
    def configured_component(self):
        """Create a configured ${className} instance."""
        config = ${className}Config(timeout=60)
        return ${className}(config)

    # Initialization Tests
    def test_initialization_default(self, component):
        """Test default initialization."""
        assert component.config is not None
        assert component.created_at is not None
        assert component._is_initialized is False

    def test_initialization_with_config(self, configured_component):
        """Test initialization with custom config."""
        assert configured_component.config.timeout == 60

    # Initialize Method Tests
    def test_initialize(self, component):
        """Test initialize method."""
        component.initialize()
        assert component._is_initialized is True

    def test_initialize_already_initialized(self, component):
        """Test initialize when already initialized."""
        component.initialize()
        component.initialize()  # Should not raise
        assert component._is_initialized is True

    # Execute Method Tests
    def test_execute_success(self, component):
        """Test successful execution."""
        data = {'key': 'value'}
        result = component.execute(data)
        
        assert result['status'] == 'success'
        assert 'timestamp' in result
        assert result['data']['processed'] is True

    def test_execute_empty_data(self, component):
        """Test execution with empty data."""
        with pytest.raises(ValueError) as exc_info:
            component.execute({})
        
        assert 'cannot be empty' in str(exc_info.value)

    def test_execute_none_data(self, component):
        """Test execution with None data."""
        with pytest.raises(ValueError):
            component.execute(None)

    def test_execute_auto_initializes(self, component):
        """Test that execute auto-initializes if needed."""
        assert component._is_initialized is False
        component.execute({'key': 'value'})
        assert component._is_initialized is True

    # Cleanup Method Tests
    def test_cleanup(self, component):
        """Test cleanup method."""
        component.initialize()
        component.cleanup()
        assert component._is_initialized is False

    # Context Manager Tests
    def test_context_manager(self):
        """Test context manager protocol."""
        with ${className}() as component:
            assert component._is_initialized is True
        assert component._is_initialized is False

    def test_context_manager_exception(self):
        """Test context manager handles exceptions."""
        with pytest.raises(ValueError):
            with ${className}() as component:
                component.execute({})

    # Process Method Tests
    def test_process_adds_processed_flag(self, component):
        """Test that _process adds processed flag."""
        component.initialize()
        data = {'original': 'data'}
        result = component._process(data)
        
        assert result['processed'] is True
        assert result['original'] == 'data'

    # Edge Cases
    def test_large_data(self, component):
        """Test with large data payload."""
        large_data = {f'key_{i}': f'value_{i}' for i in range(1000)}
        result = component.execute(large_data)
        assert result['status'] == 'success'

    def test_nested_data(self, component):
        """Test with nested data structures."""
        nested_data = {
            'level1': {
                'level2': {
                    'level3': 'value'
                }
            }
        }
        result = component.execute(nested_data)
        assert result['status'] == 'success'


class Test${className}Integration:
    """Integration tests for ${className}."""

    def test_full_workflow(self):
        """Test complete workflow."""
        config = ${className}Config(enabled=True)
        
        with ${className}(config) as component:
            result1 = component.execute({'step': 1})
            result2 = component.execute({'step': 2})
            
            assert result1['status'] == 'success'
            assert result2['status'] == 'success'


# Fixtures for pytest
@pytest.fixture(scope='module')
def shared_component():
    """Shared component for module-level tests."""
    return ${className}()


if __name__ == '__main__':
    pytest.main([__file__, '-v'])
`;
  },

  node: (name, options = {}) => {
    const className = toPascalCase(name);
    const moduleName = toCamelCase(name);
    return `/**
 * ${className} Module Tests
 * Generated by CodeMate Pro
 * 
 * Unit tests for the ${className} component.
 */

const { ${className}, create${className}Middleware, create${className}Router } = require('./${moduleName}');

describe('${className}', () => {
  let component;

  beforeEach(() => {
    component = new ${className}();
  });

  afterEach(async () => {
    if (component.isInitialized) {
      await component.cleanup();
    }
  });

  describe('Constructor', () => {
    it('should create instance with default config', () => {
      expect(component).toBeInstanceOf(${className});
      expect(component.config.enabled).toBe(true);
      expect(component.config.timeout).toBe(30000);
      expect(component.config.maxRetries).toBe(3);
    });

    it('should create instance with custom config', () => {
      const customComponent = new ${className}({
        enabled: false,
        timeout: 60000
      });
      
      expect(customComponent.config.enabled).toBe(false);
      expect(customComponent.config.timeout).toBe(60000);
    });

    it('should set createdAt timestamp', () => {
      expect(component.createdAt).toBeInstanceOf(Date);
    });

    it('should start uninitialized', () => {
      expect(component.isInitialized).toBe(false);
    });
  });

  describe('initialize()', () => {
    it('should initialize component', async () => {
      await component.initialize();
      expect(component.isInitialized).toBe(true);
    });

    it('should emit initialized event', async () => {
      const callback = jest.fn();
      component.on('initialized', callback);
      
      await component.initialize();
      
      expect(callback).toHaveBeenCalled();
    });

    it('should handle multiple initialize calls', async () => {
      await component.initialize();
      await component.initialize();
      
      expect(component.isInitialized).toBe(true);
    });
  });

  describe('execute()', () => {
    it('should execute successfully with valid data', async () => {
      const data = { key: 'value' };
      const result = await component.execute(data);
      
      expect(result.status).toBe('success');
      expect(result.timestamp).toBeDefined();
      expect(result.duration).toBeDefined();
      expect(result.data.processed).toBe(true);
    });

    it('should auto-initialize if not initialized', async () => {
      expect(component.isInitialized).toBe(false);
      
      await component.execute({ key: 'value' });
      
      expect(component.isInitialized).toBe(true);
    });

    it('should throw error for invalid data', async () => {
      await expect(component.execute(null)).rejects.toThrow('Data must be a valid object');
      await expect(component.execute('string')).rejects.toThrow('Data must be a valid object');
    });

    it('should emit executed event on success', async () => {
      const callback = jest.fn();
      component.on('executed', callback);
      
      await component.execute({ key: 'value' });
      
      expect(callback).toHaveBeenCalled();
    });

    it('should emit error event on failure', async () => {
      const callback = jest.fn();
      component.on('error', callback);
      
      try {
        await component.execute(null);
      } catch (e) {
        // Expected error
      }
      
      expect(callback).toHaveBeenCalled();
    });
  });

  describe('cleanup()', () => {
    it('should cleanup component', async () => {
      await component.initialize();
      await component.cleanup();
      
      expect(component.isInitialized).toBe(false);
    });

    it('should emit cleanup event', async () => {
      const callback = jest.fn();
      component.on('cleanup', callback);
      
      await component.initialize();
      await component.cleanup();
      
      expect(callback).toHaveBeenCalled();
    });
  });

  describe('getStatus()', () => {
    it('should return status object', () => {
      const status = component.getStatus();
      
      expect(status.name).toBe('${className}');
      expect(status.initialized).toBe(false);
      expect(status.createdAt).toBeDefined();
      expect(status.config).toBeDefined();
    });

    it('should reflect initialization state', async () => {
      await component.initialize();
      const status = component.getStatus();
      
      expect(status.initialized).toBe(true);
    });
  });
});

describe('create${className}Middleware', () => {
  it('should create middleware function', () => {
    const middleware = create${className}Middleware();
    expect(typeof middleware).toBe('function');
  });

  it('should attach component to request', async () => {
    const middleware = create${className}Middleware();
    const req = {};
    const res = {};
    const next = jest.fn();
    
    await middleware(req, res, next);
    
    expect(req.${moduleName}).toBeInstanceOf(${className});
    expect(next).toHaveBeenCalled();
  });
});

describe('create${className}Router', () => {
  it('should create router', () => {
    const router = create${className}Router();
    expect(router).toBeDefined();
  });
});
`;
  },

  java: (name, options = {}) => {
    const className = toPascalCase(name);
    return `package com.codemate.components;

import org.junit.jupiter.api.*;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.junit.jupiter.MockitoExtension;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

import java.util.HashMap;
import java.util.Map;

/**
 * ${className} Unit Tests
 * Generated by CodeMate Pro
 */
@ExtendWith(MockitoExtension.class)
@DisplayName("${className} Tests")
class ${className}Test {

    private ${className} component;
    private ${className}.${className}Config config;

    @BeforeEach
    void setUp() {
        config = ${className}.${className}Config.defaultConfig();
        component = new ${className}(config);
    }

    @AfterEach
    void tearDown() {
        if (component != null) {
            component.close();
        }
    }

    @Nested
    @DisplayName("Constructor Tests")
    class ConstructorTests {
        
        @Test
        @DisplayName("Should create with default config")
        void shouldCreateWithDefaultConfig() {
            ${className} defaultComponent = new ${className}();
            
            assertNotNull(defaultComponent);
            assertNotNull(defaultComponent.getConfig());
            assertTrue(defaultComponent.getConfig().isEnabled());
        }

        @Test
        @DisplayName("Should create with custom config")
        void shouldCreateWithCustomConfig() {
            config.setEnabled(false);
            config.setTimeout(60000);
            
            ${className} customComponent = new ${className}(config);
            
            assertFalse(customComponent.getConfig().isEnabled());
            assertEquals(60000, customComponent.getConfig().getTimeout());
        }

        @Test
        @DisplayName("Should throw on null config")
        void shouldThrowOnNullConfig() {
            assertThrows(NullPointerException.class, () -> new ${className}(null));
        }
    }

    @Nested
    @DisplayName("Initialize Tests")
    class InitializeTests {
        
        @Test
        @DisplayName("Should initialize successfully")
        void shouldInitialize() {
            assertFalse(component.isInitialized());
            
            component.initialize();
            
            assertTrue(component.isInitialized());
        }

        @Test
        @DisplayName("Should handle multiple initialize calls")
        void shouldHandleMultipleInitializeCalls() {
            component.initialize();
            component.initialize();
            
            assertTrue(component.isInitialized());
        }
    }

    @Nested
    @DisplayName("Execute Tests")
    class ExecuteTests {
        
        @Test
        @DisplayName("Should execute with valid data")
        void shouldExecuteWithValidData() {
            Map<String, Object> data = new HashMap<>();
            data.put("key", "value");
            
            ${className}.${className}Result result = component.execute(data);
            
            assertEquals("success", result.getStatus());
            assertNotNull(result.getTimestamp());
            assertTrue((Boolean) result.getData().get("processed"));
        }

        @Test
        @DisplayName("Should auto-initialize on execute")
        void shouldAutoInitialize() {
            assertFalse(component.isInitialized());
            
            Map<String, Object> data = new HashMap<>();
            data.put("key", "value");
            component.execute(data);
            
            assertTrue(component.isInitialized());
        }

        @Test
        @DisplayName("Should throw on null data")
        void shouldThrowOnNullData() {
            assertThrows(IllegalArgumentException.class, () -> component.execute(null));
        }

        @Test
        @DisplayName("Should throw on empty data")
        void shouldThrowOnEmptyData() {
            assertThrows(IllegalArgumentException.class, () -> component.execute(new HashMap<>()));
        }

        @Test
        @DisplayName("Should throw when disabled")
        void shouldThrowWhenDisabled() {
            config.setEnabled(false);
            ${className} disabledComponent = new ${className}(config);
            
            Map<String, Object> data = new HashMap<>();
            data.put("key", "value");
            
            assertThrows(IllegalStateException.class, () -> disabledComponent.execute(data));
        }
    }

    @Nested
    @DisplayName("GetStatus Tests")
    class GetStatusTests {
        
        @Test
        @DisplayName("Should return correct status")
        void shouldReturnStatus() {
            Map<String, Object> status = component.getStatus();
            
            assertEquals("${className}", status.get("name"));
            assertFalse((Boolean) status.get("initialized"));
            assertNotNull(status.get("createdAt"));
        }

        @Test
        @DisplayName("Should reflect initialization state")
        void shouldReflectInitializationState() {
            component.initialize();
            
            Map<String, Object> status = component.getStatus();
            
            assertTrue((Boolean) status.get("initialized"));
        }
    }

    @Nested
    @DisplayName("Cleanup Tests")
    class CleanupTests {
        
        @Test
        @DisplayName("Should cleanup successfully")
        void shouldCleanup() {
            component.initialize();
            assertTrue(component.isInitialized());
            
            component.cleanup();
            
            assertFalse(component.isInitialized());
        }

        @Test
        @DisplayName("Should work with try-with-resources")
        void shouldWorkWithTryWithResources() {
            try (${className} autoCloseable = new ${className}()) {
                autoCloseable.initialize();
                assertTrue(autoCloseable.isInitialized());
            }
            // Component should be closed after try block
        }
    }

    @Nested
    @DisplayName("Config Tests")
    class ConfigTests {
        
        @Test
        @DisplayName("Should have correct default values")
        void shouldHaveDefaultValues() {
            ${className}.${className}Config defaultConfig = ${className}.${className}Config.defaultConfig();
            
            assertTrue(defaultConfig.isEnabled());
            assertEquals(30000, defaultConfig.getTimeout());
            assertEquals(3, defaultConfig.getMaxRetries());
        }

        @Test
        @DisplayName("Should allow setting values")
        void shouldAllowSettingValues() {
            ${className}.${className}Config testConfig = new ${className}.${className}Config();
            
            testConfig.setEnabled(false);
            testConfig.setTimeout(5000);
            testConfig.setMaxRetries(10);
            
            assertFalse(testConfig.isEnabled());
            assertEquals(5000, testConfig.getTimeout());
            assertEquals(10, testConfig.getMaxRetries());
        }
    }

    @Nested
    @DisplayName("Edge Cases")
    class EdgeCaseTests {
        
        @Test
        @DisplayName("Should handle large data")
        void shouldHandleLargeData() {
            Map<String, Object> largeData = new HashMap<>();
            for (int i = 0; i < 1000; i++) {
                largeData.put("key" + i, "value" + i);
            }
            
            ${className}.${className}Result result = component.execute(largeData);
            
            assertEquals("success", result.getStatus());
        }

        @Test
        @DisplayName("Should handle nested data")
        void shouldHandleNestedData() {
            Map<String, Object> nestedData = new HashMap<>();
            Map<String, Object> inner = new HashMap<>();
            inner.put("innerKey", "innerValue");
            nestedData.put("outer", inner);
            
            ${className}.${className}Result result = component.execute(nestedData);
            
            assertEquals("success", result.getStatus());
        }
    }
}
`;
  }
};

// Template generators for each framework
const generators = {
  react: (name, options = {}) => {
    const componentName = toPascalCase(name);
    return `import React, { useState, useEffect } from 'react';

interface ${componentName}Props {
  className?: string;
  children?: React.ReactNode;
}

/**
 * ${componentName} Component
 * Generated by CodeMate Pro
 */
export const ${componentName}: React.FC<${componentName}Props> = ({ 
  className = '',
  children 
}) => {
  const [isLoading, setIsLoading] = useState(false);

  useEffect(() => {
    // Component mount logic
    return () => {
      // Cleanup logic
    };
  }, []);

  return (
    <div className={\`${componentName.toLowerCase()}-container \${className}\`}>
      <div className="${componentName.toLowerCase()}-content">
        {isLoading ? (
          <span>Loading...</span>
        ) : (
          children
        )}
      </div>
    </div>
  );
};

export default ${componentName};
`;
  },

  angular: (name, options = {}) => {
    const componentName = toPascalCase(name);
    const selector = toKebabCase(name);
    return `import { Component, Input, Output, EventEmitter, OnInit, OnDestroy } from '@angular/core';

/**
 * ${componentName} Component
 * Generated by CodeMate Pro
 */
@Component({
  selector: 'app-${selector}',
  template: \`
    <div class="${selector}-container" [ngClass]="customClass">
      <div class="${selector}-content">
        <ng-container *ngIf="!isLoading; else loadingTemplate">
          <ng-content></ng-content>
        </ng-container>
        <ng-template #loadingTemplate>
          <span>Loading...</span>
        </ng-template>
      </div>
    </div>
  \`,
  styles: [\`
    .${selector}-container {
      display: block;
    }
    .${selector}-content {
      padding: 1rem;
    }
  \`]
})
export class ${componentName}Component implements OnInit, OnDestroy {
  @Input() customClass = '';
  @Input() isLoading = false;
  @Output() actionTriggered = new EventEmitter<void>();

  ngOnInit(): void {
    // Component initialization logic
  }

  ngOnDestroy(): void {
    // Cleanup logic
  }

  onAction(): void {
    this.actionTriggered.emit();
  }
}
`;
  },

  python: (name, options = {}) => {
    const className = toPascalCase(name);
    const moduleName = toSnakeCase(name);
    return `"""
${className} Module
Generated by CodeMate Pro

A reusable Python component/service for your application.
"""

from typing import Any, Dict, List, Optional
from dataclasses import dataclass, field
from datetime import datetime
import logging

logger = logging.getLogger(__name__)


@dataclass
class ${className}Config:
    """Configuration for ${className}."""
    enabled: bool = True
    timeout: int = 30
    max_retries: int = 3
    options: Dict[str, Any] = field(default_factory=dict)


class ${className}:
    """
    ${className} - A reusable component.
    
    Attributes:
        config: Configuration settings for the component
        created_at: Timestamp when component was instantiated
    
    Example:
        >>> component = ${className}()
        >>> result = component.execute(data={'key': 'value'})
    """
    
    def __init__(self, config: Optional[${className}Config] = None):
        self.config = config or ${className}Config()
        self.created_at = datetime.now()
        self._is_initialized = False
        logger.info(f"${className} initialized with config: {self.config}")
    
    def initialize(self) -> None:
        """Initialize the component resources."""
        if self._is_initialized:
            logger.warning("${className} already initialized")
            return
        
        # Initialization logic here
        self._is_initialized = True
        logger.info("${className} initialization complete")
    
    def execute(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Execute the main component logic.
        
        Args:
            data: Input data dictionary
            
        Returns:
            Result dictionary with processed data
            
        Raises:
            ValueError: If data is invalid
        """
        if not self._is_initialized:
            self.initialize()
        
        if not data:
            raise ValueError("Data cannot be empty")
        
        result = {
            'status': 'success',
            'timestamp': datetime.now().isoformat(),
            'data': self._process(data)
        }
        
        return result
    
    def _process(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Internal processing logic."""
        # Add your processing logic here
        processed = {**data, 'processed': True}
        return processed
    
    def cleanup(self) -> None:
        """Cleanup component resources."""
        self._is_initialized = False
        logger.info("${className} cleanup complete")
    
    def __enter__(self):
        """Context manager entry."""
        self.initialize()
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        """Context manager exit."""
        self.cleanup()
        return False


# FastAPI integration example
def create_${moduleName}_router():
    """Create FastAPI router for ${className}."""
    from fastapi import APIRouter, HTTPException
    from pydantic import BaseModel
    
    router = APIRouter(prefix="/${moduleName}", tags=["${className}"])
    component = ${className}()
    
    class ${className}Request(BaseModel):
        data: Dict[str, Any]
    
    class ${className}Response(BaseModel):
        status: str
        timestamp: str
        data: Dict[str, Any]
    
    @router.post("/execute", response_model=${className}Response)
    async def execute_${moduleName}(request: ${className}Request):
        try:
            result = component.execute(request.data)
            return result
        except ValueError as e:
            raise HTTPException(status_code=400, detail=str(e))
    
    return router


if __name__ == "__main__":
    # Example usage
    with ${className}() as component:
        result = component.execute({'example': 'data'})
        print(f"Result: {result}")
`;
  },

  node: (name, options = {}) => {
    const className = toPascalCase(name);
    const moduleName = toCamelCase(name);
    return `/**
 * ${className} Module
 * Generated by CodeMate Pro
 * 
 * A reusable Node.js component/service for your application.
 */

const EventEmitter = require('events');

/**
 * Configuration options for ${className}
 * @typedef {Object} ${className}Config
 * @property {boolean} enabled - Whether the component is enabled
 * @property {number} timeout - Operation timeout in milliseconds
 * @property {number} maxRetries - Maximum retry attempts
 */

/**
 * ${className} - A reusable Node.js component
 * @extends EventEmitter
 */
class ${className} extends EventEmitter {
  /**
   * Create a new ${className} instance
   * @param {${className}Config} config - Configuration options
   */
  constructor(config = {}) {
    super();
    this.config = {
      enabled: true,
      timeout: 30000,
      maxRetries: 3,
      ...config
    };
    this.isInitialized = false;
    this.createdAt = new Date();
  }

  /**
   * Initialize the component
   * @returns {Promise<void>}
   */
  async initialize() {
    if (this.isInitialized) {
      console.warn('${className} already initialized');
      return;
    }

    // Add initialization logic here
    this.isInitialized = true;
    this.emit('initialized');
    console.log('${className} initialized successfully');
  }

  /**
   * Execute the main component logic
   * @param {Object} data - Input data
   * @returns {Promise<Object>} Result object
   * @throws {Error} If data is invalid
   */
  async execute(data) {
    if (!this.isInitialized) {
      await this.initialize();
    }

    if (!data || typeof data !== 'object') {
      throw new Error('Data must be a valid object');
    }

    const startTime = Date.now();

    try {
      const processed = await this._process(data);
      
      const result = {
        status: 'success',
        timestamp: new Date().toISOString(),
        duration: Date.now() - startTime,
        data: processed
      };

      this.emit('executed', result);
      return result;
    } catch (error) {
      this.emit('error', error);
      throw error;
    }
  }

  /**
   * Internal processing logic
   * @private
   * @param {Object} data - Input data
   * @returns {Promise<Object>} Processed data
   */
  async _process(data) {
    // Add your processing logic here
    return {
      ...data,
      processed: true,
      processedAt: new Date().toISOString()
    };
  }

  /**
   * Cleanup component resources
   * @returns {Promise<void>}
   */
  async cleanup() {
    this.isInitialized = false;
    this.emit('cleanup');
    console.log('${className} cleanup complete');
  }

  /**
   * Get component status
   * @returns {Object} Status information
   */
  getStatus() {
    return {
      name: '${className}',
      initialized: this.isInitialized,
      createdAt: this.createdAt,
      config: this.config
    };
  }
}

// Express.js middleware factory
/**
 * Create Express middleware for ${className}
 * @param {${className}Config} config - Configuration options
 * @returns {Function} Express middleware
 */
function create${className}Middleware(config = {}) {
  const component = new ${className}(config);

  return async (req, res, next) => {
    try {
      req.${moduleName} = component;
      next();
    } catch (error) {
      next(error);
    }
  };
}

// Express router factory
/**
 * Create Express router for ${className}
 * @returns {Object} Express router
 */
function create${className}Router() {
  const express = require('express');
  const router = express.Router();
  const component = new ${className}();

  router.post('/execute', async (req, res, next) => {
    try {
      const result = await component.execute(req.body);
      res.json(result);
    } catch (error) {
      next(error);
    }
  });

  router.get('/status', (req, res) => {
    res.json(component.getStatus());
  });

  return router;
}

module.exports = {
  ${className},
  create${className}Middleware,
  create${className}Router
};
`;
  },

  java: (name, options = {}) => {
    const className = toPascalCase(name);
    return `package com.codemate.components;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.logging.Logger;

/**
 * ${className} Component
 * Generated by CodeMate Pro
 * 
 * <p>A reusable Java component for your application.</p>
 * 
 * <p>Example usage:</p>
 * <pre>
 * ${className} component = new ${className}();
 * Map&lt;String, Object&gt; result = component.execute(inputData);
 * </pre>
 * 
 * @author CodeMate Pro Generator
 * @version 1.0.0
 */
public class ${className} implements AutoCloseable {
    
    private static final Logger LOGGER = Logger.getLogger(${className}.class.getName());
    
    private final ${className}Config config;
    private final LocalDateTime createdAt;
    private boolean initialized;
    
    /**
     * Configuration for ${className}
     */
    public static class ${className}Config {
        private boolean enabled = true;
        private int timeout = 30000;
        private int maxRetries = 3;
        
        public boolean isEnabled() { return enabled; }
        public void setEnabled(boolean enabled) { this.enabled = enabled; }
        
        public int getTimeout() { return timeout; }
        public void setTimeout(int timeout) { this.timeout = timeout; }
        
        public int getMaxRetries() { return maxRetries; }
        public void setMaxRetries(int maxRetries) { this.maxRetries = maxRetries; }
        
        public static ${className}Config defaultConfig() {
            return new ${className}Config();
        }
    }
    
    /**
     * Result of component execution
     */
    public static class ${className}Result {
        private final String status;
        private final LocalDateTime timestamp;
        private final Map<String, Object> data;
        
        public ${className}Result(String status, Map<String, Object> data) {
            this.status = status;
            this.timestamp = LocalDateTime.now();
            this.data = data;
        }
        
        public String getStatus() { return status; }
        public LocalDateTime getTimestamp() { return timestamp; }
        public Map<String, Object> getData() { return data; }
    }
    
    /**
     * Create ${className} with default configuration
     */
    public ${className}() {
        this(${className}Config.defaultConfig());
    }
    
    /**
     * Create ${className} with custom configuration
     * @param config Configuration settings
     */
    public ${className}(${className}Config config) {
        this.config = Objects.requireNonNull(config, "Config cannot be null");
        this.createdAt = LocalDateTime.now();
        this.initialized = false;
        LOGGER.info("${className} instance created");
    }
    
    /**
     * Initialize component resources
     */
    public void initialize() {
        if (initialized) {
            LOGGER.warning("${className} already initialized");
            return;
        }
        
        // Add initialization logic here
        initialized = true;
        LOGGER.info("${className} initialized successfully");
    }
    
    /**
     * Execute the main component logic
     * @param data Input data map
     * @return Result containing processed data
     * @throws IllegalArgumentException if data is null or empty
     * @throws IllegalStateException if component is not enabled
     */
    public ${className}Result execute(Map<String, Object> data) {
        if (!config.isEnabled()) {
            throw new IllegalStateException("${className} is not enabled");
        }
        
        if (data == null || data.isEmpty()) {
            throw new IllegalArgumentException("Data cannot be null or empty");
        }
        
        if (!initialized) {
            initialize();
        }
        
        Map<String, Object> processed = process(data);
        return new ${className}Result("success", processed);
    }
    
    /**
     * Internal processing logic
     * @param data Input data
     * @return Processed data
     */
    private Map<String, Object> process(Map<String, Object> data) {
        Map<String, Object> result = new HashMap<>(data);
        result.put("processed", true);
        result.put("processedAt", LocalDateTime.now().toString());
        return result;
    }
    
    /**
     * Get component status
     * @return Status information map
     */
    public Map<String, Object> getStatus() {
        Map<String, Object> status = new HashMap<>();
        status.put("name", "${className}");
        status.put("initialized", initialized);
        status.put("createdAt", createdAt.toString());
        status.put("enabled", config.isEnabled());
        return status;
    }
    
    /**
     * Cleanup component resources
     */
    public void cleanup() {
        initialized = false;
        LOGGER.info("${className} cleanup complete");
    }
    
    @Override
    public void close() {
        cleanup();
    }
    
    /**
     * Get the configuration
     * @return Current configuration
     */
    public ${className}Config getConfig() {
        return config;
    }
    
    /**
     * Check if component is initialized
     * @return true if initialized
     */
    public boolean isInitialized() {
        return initialized;
    }
}

// Spring Boot Controller (Optional - for REST API)
/*
import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;

@RestController
@RequestMapping("/api/${className.toLowerCase()}")
public class ${className}Controller {
    
    private final ${className} component;
    
    public ${className}Controller() {
        this.component = new ${className}();
    }
    
    @PostMapping("/execute")
    public ResponseEntity<${className}.${className}Result> execute(@RequestBody Map<String, Object> data) {
        ${className}.${className}Result result = component.execute(data);
        return ResponseEntity.ok(result);
    }
    
    @GetMapping("/status")
    public ResponseEntity<Map<String, Object>> getStatus() {
        return ResponseEntity.ok(component.getStatus());
    }
}
*/
`;
  }
};

// Helper functions
function toPascalCase(str) {
  return str
    .replace(/[-_\s]+(.)?/g, (_, c) => (c ? c.toUpperCase() : ''))
    .replace(/^(.)/, (c) => c.toUpperCase());
}

function toCamelCase(str) {
  const pascal = toPascalCase(str);
  return pascal.charAt(0).toLowerCase() + pascal.slice(1);
}

function toKebabCase(str) {
  return str
    .replace(/([a-z])([A-Z])/g, '$1-$2')
    .replace(/[\s_]+/g, '-')
    .toLowerCase();
}

function toSnakeCase(str) {
  return str
    .replace(/([a-z])([A-Z])/g, '$1_$2')
    .replace(/[\s-]+/g, '_')
    .toLowerCase();
}

function getFileExtension(framework) {
  const extensions = {
    react: '.tsx',
    angular: '.component.ts',
    python: '.py',
    node: '.js',
    java: '.java'
  };
  return extensions[framework] || '.txt';
}

function getFileName(name, framework) {
  switch (framework) {
    case 'react':
      return `${toPascalCase(name)}${getFileExtension(framework)}`;
    case 'angular':
      return `${toKebabCase(name)}${getFileExtension(framework)}`;
    case 'python':
      return `${toSnakeCase(name)}${getFileExtension(framework)}`;
    case 'node':
      return `${toCamelCase(name)}${getFileExtension(framework)}`;
    case 'java':
      return `${toPascalCase(name)}${getFileExtension(framework)}`;
    default:
      return `${name}${getFileExtension(framework)}`;
  }
}

function generateComponent(name, framework, outputDir) {
  if (!SUPPORTED_FRAMEWORKS.includes(framework)) {
    throw new Error(`Unsupported framework: ${framework}. Supported: ${SUPPORTED_FRAMEWORKS.join(', ')}`);
  }

  const generator = generators[framework];
  const content = generator(name);
  const fileName = getFileName(name, framework);
  const targetDir = outputDir || path.join(COMPONENTS_DIR, framework);
  
  // Create directory if it doesn't exist
  if (!fs.existsSync(targetDir)) {
    fs.mkdirSync(targetDir, { recursive: true });
  }

  const filePath = path.join(targetDir, fileName);
  fs.writeFileSync(filePath, content, 'utf-8');
  
  return { filePath, fileName, content };
}

function getTestFileName(name, framework) {
  switch (framework) {
    case 'react':
      return `${toPascalCase(name)}.test.tsx`;
    case 'angular':
      return `${toKebabCase(name)}.component.spec.ts`;
    case 'python':
      return `test_${toSnakeCase(name)}.py`;
    case 'node':
      return `${toCamelCase(name)}.test.js`;
    case 'java':
      return `${toPascalCase(name)}Test.java`;
    default:
      return `${name}.test.txt`;
  }
}

function generateTest(name, framework, outputDir) {
  if (!SUPPORTED_FRAMEWORKS.includes(framework)) {
    throw new Error(`Unsupported framework: ${framework}. Supported: ${SUPPORTED_FRAMEWORKS.join(', ')}`);
  }

  const generator = testGenerators[framework];
  const content = generator(name);
  const fileName = getTestFileName(name, framework);
  const targetDir = outputDir || path.join(COMPONENTS_DIR, framework, '__tests__');
  
  // Create directory if it doesn't exist
  if (!fs.existsSync(targetDir)) {
    fs.mkdirSync(targetDir, { recursive: true });
  }

  const filePath = path.join(targetDir, fileName);
  fs.writeFileSync(filePath, content, 'utf-8');
  
  return { filePath, fileName, content };
}

// Interactive mode
async function interactiveMode() {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });

  const question = (prompt) => new Promise(resolve => rl.question(prompt, resolve));

  banner();
  log('Enter component details (or type "exit" to quit)\n', 'yellow');

  while (true) {
    const name = await question(`${colors.cyan}Component name: ${colors.reset}`);
    if (name.toLowerCase() === 'exit') break;

    log(`\nAvailable frameworks: ${SUPPORTED_FRAMEWORKS.join(', ')}`, 'blue');
    const framework = await question(`${colors.cyan}Framework [react]: ${colors.reset}`);
    const selectedFramework = framework.toLowerCase() || 'react';

    try {
      const result = generateComponent(name, selectedFramework);
      log(`\n‚úÖ Component created successfully!`, 'green');
      log(`üìÅ File: ${result.filePath}`, 'blue');
      log('', 'reset');
    } catch (error) {
      log(`\n‚ùå Error: ${error.message}`, 'red');
    }
  }

  rl.close();
  log('\nGoodbye! üëã', 'cyan');
}

// CLI command handler
function handleCommand(args) {
  const [command, ...params] = args;

  switch (command) {
    case 'generate':
    case 'g':
      if (params.length < 2) {
        log('Usage: codemate generate <framework> <component-name> [output-dir]', 'yellow');
        log(`Frameworks: ${SUPPORTED_FRAMEWORKS.join(', ')}`, 'blue');
        process.exit(1);
      }
      const [framework, name, outputDir] = params;
      try {
        const result = generateComponent(name, framework.toLowerCase(), outputDir);
        log(`‚úÖ Created: ${result.filePath}`, 'green');
      } catch (error) {
        log(`‚ùå Error: ${error.message}`, 'red');
        process.exit(1);
      }
      break;

    case 'test':
    case 't':
      if (params.length < 2) {
        log('Usage: codemate test <framework> <component-name> [output-dir]', 'yellow');
        log(`Frameworks: ${SUPPORTED_FRAMEWORKS.join(', ')}`, 'blue');
        process.exit(1);
      }
      const [testFramework, testName, testOutputDir] = params;
      try {
        const testResult = generateTest(testName, testFramework.toLowerCase(), testOutputDir);
        log(`‚úÖ Test created: ${testResult.filePath}`, 'green');
      } catch (error) {
        log(`‚ùå Error: ${error.message}`, 'red');
        process.exit(1);
      }
      break;

    case 'both':
    case 'b':
      if (params.length < 2) {
        log('Usage: codemate both <framework> <component-name> [output-dir]', 'yellow');
        log('Creates both component and test file', 'blue');
        process.exit(1);
      }
      const [bothFramework, bothName, bothOutputDir] = params;
      try {
        const compResult = generateComponent(bothName, bothFramework.toLowerCase(), bothOutputDir);
        log(`‚úÖ Component: ${compResult.filePath}`, 'green');
        const bothTestResult = generateTest(bothName, bothFramework.toLowerCase());
        log(`‚úÖ Test: ${bothTestResult.filePath}`, 'green');
      } catch (error) {
        log(`‚ùå Error: ${error.message}`, 'red');
        process.exit(1);
      }
      break;

    case 'list':
    case 'l':
      log('\nSupported Frameworks:', 'cyan');
      SUPPORTED_FRAMEWORKS.forEach(f => {
        log(`  ‚Ä¢ ${f} (${getFileExtension(f)})`, 'blue');
      });
      break;

    case 'interactive':
    case 'i':
      interactiveMode();
      break;

    case 'help':
    case 'h':
    default:
      banner();
      log('Commands:', 'yellow');
      log('  generate, g <framework> <name> [dir]  - Generate a component', 'reset');
      log('  list, l                               - List supported frameworks', 'reset');
      log('  interactive, i                        - Interactive mode', 'reset');
      log('  help, h                               - Show this help', 'reset');
      log('\nExamples:', 'yellow');
      log('  codemate generate react UserCard', 'reset');
      log('  codemate g angular user-profile', 'reset');
      log('  codemate g python data_processor', 'reset');
      log('  codemate g node authService', 'reset');
      log('  codemate g java OrderManager', 'reset');
      break;
  }
}

// Main execution
const args = process.argv.slice(2);
if (args.length === 0) {
  interactiveMode();
} else {
  handleCommand(args);
}

module.exports = { generateComponent, generators, SUPPORTED_FRAMEWORKS };
